<section class="hero-stage" data-hero-root>
  <canvas class="hero-canvas" data-hero-canvas aria-hidden="true"></canvas>

  <div class="hero-centerline" aria-hidden="true"></div>

  <p class="hero-fallback-title" data-hero-fallback-title>
    <span>OVER THE </span><strong>RAINBOW</strong>
  </p>

  <div class="hero-action-grid" data-hero-actions>
    <article>
      <h2>MISSION</h2>
      <p>博客首页</p>
      <a href="/about/">GO</a>
    </article>
    <article class="is-primary">
      <h2>IDENTITY</h2>
      <p>内容与系统</p>
      <a href="/posts/">GO</a>
    </article>
    <article>
      <h2>SOLUTION</h2>
      <p>Markdown 写作</p>
      <a href="/tags/">GO</a>
    </article>
  </div>

  <script is:inline>
    (() => {
      const root = document.querySelector("[data-hero-root]");
      const canvas = root?.querySelector("[data-hero-canvas]");
      const actionGrid = root?.querySelector("[data-hero-actions]");
      const fallbackTitle = root?.querySelector("[data-hero-fallback-title]");
      if (!root || !canvas || !actionGrid || !fallbackTitle) return;

      const actionItems = Array.from(actionGrid.querySelectorAll("article"));

      const mediaReduce = window.matchMedia("(prefers-reduced-motion: reduce)");
      if (mediaReduce.matches) {
        root.classList.add("is-reduced");
        fallbackTitle.classList.add("is-visible");
        actionGrid.classList.add("is-visible");
        actionItems.forEach((item) => item.classList.add("is-on"));
        return;
      }

      const ctx = canvas.getContext("2d", { alpha: true });
      if (!ctx) {
        root.classList.add("is-reduced");
        fallbackTitle.classList.add("is-visible");
        actionGrid.classList.add("is-visible");
        actionItems.forEach((item) => item.classList.add("is-on"));
        return;
      }
      fallbackTitle.classList.remove("is-visible");
      fallbackTitle.style.opacity = "0";

      const CYCLE_MS = 12500;
      const TEXT = "OVER THE RAINBOW";
      const SAMPLE_STEP = 4;
      const MAX_TEXT_PARTICLES = 980;
      const AMBIENT_COUNT = 120;
      const EDGE_GUTTER_MIN = 24;

      const P0 = 0.14;
      const P1 = 0.34;
      const P2 = 0.51;
      const P3 = 0.66;
      const P4 = 0.9;
      const FUNNEL_START = P2;

      const COLORS = ["#2166d1", "#f28e2b", "#e15759", "#76b041", "#6f49c7", "#27a4c9", "#f0d23f"];
      const TEXT_COLORS = ["#1a2235", "#2c4575", "#5c7598", "#8f7d50", "#839f5e", "#4a8ea3", "#7054a8"];

      let dpr = 1;
      let width = 0;
      let height = 0;
      let cx = 0;
      let cy = 0;

      let running = true;
      let rafId = 0;
      let startTime = performance.now();
      let pausedAt = 0;

      const textParticles = [];
      const ambientParticles = [];

      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const randomRange = (min, max) => min + Math.random() * (max - min);
      const weightedPick = (choices) => {
        const total = choices.reduce((sum, c) => sum + c.w, 0);
        let roll = Math.random() * total;
        for (let i = 0; i < choices.length; i += 1) {
          roll -= choices[i].w;
          if (roll <= 0) return choices[i];
        }
        return choices[choices.length - 1];
      };
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
      const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;

      function setCanvasSize() {
        const rect = root.getBoundingClientRect();
        dpr = clamp(window.devicePixelRatio || 1, 1, 2);
        width = Math.max(320, Math.floor(rect.width));
        height = Math.max(420, Math.floor(rect.height));
        cx = width / 2;
        cy = height / 2;

        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function textColorForX(x, minX, maxX) {
        const t = clamp((x - minX) / Math.max(1, maxX - minX), 0, 1);
        const idx = clamp(Math.floor(t * TEXT_COLORS.length), 0, TEXT_COLORS.length - 1);
        return TEXT_COLORS[idx];
      }

      function buildTextParticles() {
        textParticles.length = 0;

        const offscreen = document.createElement("canvas");
        offscreen.width = width;
        offscreen.height = height;
        const offctx = offscreen.getContext("2d");
        if (!offctx) return;

        const fontSize = Math.floor(clamp(width * 0.062, 34, 72));
        offctx.clearRect(0, 0, width, height);
        offctx.fillStyle = "#000";
        offctx.font = `500 ${fontSize}px "Manrope", sans-serif`;
        offctx.textAlign = "center";
        offctx.textBaseline = "middle";
        offctx.fillText(TEXT, cx, cy - 18);

        const imageData = offctx.getImageData(0, 0, width, height).data;
        const points = [];
        let minX = width;
        let maxX = 0;

        for (let y = 0; y < height; y += SAMPLE_STEP) {
          for (let x = 0; x < width; x += SAMPLE_STEP) {
            const a = imageData[(y * width + x) * 4 + 3];
            if (a > 80) {
              points.push({ x, y });
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
            }
          }
        }

        const stride = Math.max(1, Math.floor(points.length / MAX_TEXT_PARTICLES));
        const scatterRadius = Math.min(width, height) * 0.66;
        const scatterXMax = Math.max(140, width * 0.48);
        const scatterYMax = Math.max(90, height * 0.36);
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const maxBurstRadius = Math.max(120, cx - edgeGutter);

        for (let i = 0; i < points.length; i += stride) {
          const p = points[i];
          const angle = randomRange(0, Math.PI * 2);
          const radial = scatterRadius * randomRange(0.72, 1.18);
          const nx = ((p.x - minX) / Math.max(1, maxX - minX)) * 2 - 1;
          const burstAngle = randomRange(0, Math.PI * 2);
          const burstRadius = randomRange(maxBurstRadius * 0.36, maxBurstRadius * 0.98);

          const sizeBucket = weightedPick([
            { w: 0.82, min: 0.68, max: 1.45 },
            { w: 0.14, min: 1.55, max: 2.45 },
            { w: 0.04, min: 2.55, max: 3.9 },
          ]);

          textParticles.push({
            tx: p.x,
            ty: p.y,
            color: textColorForX(p.x, minX, maxX),
            size: randomRange(sizeBucket.min, sizeBucket.max),
            seed: randomRange(0, Math.PI * 2),
            nx,
            ny: (p.y - cy) / Math.max(1, height * 0.35),
            scatterX: cx + Math.cos(angle) * radial * 1.45,
            scatterY: cy + Math.sin(angle) * radial * 0.72,
            centerX: cx + randomRange(-6, 6),
            centerY: cy + randomRange(-6, 6),
            burstX: cx + Math.cos(burstAngle) * burstRadius,
            burstY: cy + Math.sin(burstAngle) * burstRadius * 0.9,
            square: Math.random() > 0.25,
          });
        }

        for (let i = 0; i < textParticles.length; i += 1) {
          const p = textParticles[i];
          p.scatterX = clamp(p.scatterX, cx - scatterXMax, cx + scatterXMax);
          p.scatterY = clamp(p.scatterY, cy - scatterYMax, cy + scatterYMax);
        }
      }

      function buildAmbientParticles() {
        ambientParticles.length = 0;
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const maxAmbientRadius = Math.max(100, cx - edgeGutter);
        for (let i = 0; i < AMBIENT_COUNT; i += 1) {
          const sizeBucket = weightedPick([
            { w: 0.74, min: 1.1, max: 2.8 },
            { w: 0.2, min: 2.9, max: 5.5 },
            { w: 0.06, min: 5.6, max: 10.8 },
          ]);
          const depth = Math.pow(Math.random(), 1.45);

          ambientParticles.push({
            angle: randomRange(0, Math.PI * 2),
            radius: randomRange(maxAmbientRadius * 0.22, maxAmbientRadius * 0.98),
            spin: randomRange(0.0002, 0.00065) * (Math.random() > 0.5 ? 1 : -1),
            drift: randomRange(-26, 26),
            size: randomRange(sizeBucket.min, sizeBucket.max),
            alpha: randomRange(0.22, 0.86),
            depth,
            zPhase: randomRange(0, Math.PI * 2),
            zSpeed: randomRange(0.00045, 0.001),
            color: COLORS[i % COLORS.length],
          });
        }
      }

      function initScene() {
        setCanvasSize();
        buildTextParticles();
        buildAmbientParticles();
      }

      function drawBackgroundGlow() {
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, width * 0.46);
        gradient.addColorStop(0, "rgba(120, 150, 210, 0.075)");
        gradient.addColorStop(1, "rgba(120, 150, 210, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      function drawSourceTitle(phase) {
        if (phase >= P1) return;

        let alpha = 1;
        if (phase > P0) {
          const t = (phase - P0) / Math.max(0.001, P1 - P0);
          alpha = 1 - easeInOutCubic(t);
        }
        if (alpha <= 0) return;

        const fontSize = Math.floor(clamp(width * 0.062, 34, 72));
        const darkPart = "OVER THE ";
        const rainbowPart = "RAINBOW";

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = `500 ${fontSize}px "Manrope", sans-serif`;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        const darkWidth = ctx.measureText(darkPart).width;
        const rainbowWidth = ctx.measureText(rainbowPart).width;
        const startX = cx - (darkWidth + rainbowWidth) / 2;
        const y = cy - 18;

        ctx.fillStyle = "#16243f";
        ctx.fillText(darkPart, startX, y);

        const gradient = ctx.createLinearGradient(startX + darkWidth, y, startX + darkWidth + rainbowWidth, y);
        gradient.addColorStop(0, "#33496f");
        gradient.addColorStop(0.15, "#5f79ab");
        gradient.addColorStop(0.33, "#df9f52");
        gradient.addColorStop(0.5, "#c76064");
        gradient.addColorStop(0.66, "#76a84b");
        gradient.addColorStop(0.82, "#33a2c9");
        gradient.addColorStop(1, "#7054a8");
        ctx.fillStyle = gradient;
        ctx.fillText(rainbowPart, startX + darkWidth, y);
        ctx.restore();
      }

      function funnelPoint(u, v, liftProgress, elapsed) {
        const outerRadius = width * 0.44;
        const neckRadius = width * 0.108;
        const cylinderRadius = width * 0.09;
        const absV = Math.abs(v);
        const smoothProfile = absV * absV * (3 - 2 * absV);
        const hourglassRadius = lerp(neckRadius, outerRadius, Math.pow(smoothProfile, 0.92));
        const morphProgress = clamp((liftProgress - 0.2) / 0.8, 0, 1);
        const radius = lerp(cylinderRadius, hourglassRadius, easeOutCubic(morphProgress));

        const yExtent = lerp(20, Math.min(height * 0.62, 440), easeOutCubic(liftProgress));
        const spin = elapsed * 0.000055;
        const yaw = Math.sin(elapsed * 0.00012) * 0.032;
        const angle = u + spin;

        const px = Math.cos(angle) * radius;
        const py = v * yExtent;
        const pz = Math.sin(angle) * radius;

        const pitch = lerp(-1.08, -0.56, easeOutCubic(liftProgress));
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const ry = py * cosX - pz * sinX;
        const rz1 = py * sinX + pz * cosX;

        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const rx = px * cosY + rz1 * sinY;
        const rz = -px * sinY + rz1 * cosY;

        const zoom = lerp(0.3, 1.06, easeOutCubic(liftProgress));
        const zTranslate = lerp(-760, -110, easeOutCubic(liftProgress));
        const camera = 1360;
        const zWorld = rz * zoom + zTranslate;
        const perspective = camera / Math.max(200, camera - zWorld);

        return {
          x: cx + rx * zoom * perspective,
          y: cy + ry * zoom * perspective,
        };
      }

      function drawFunnel(phase, elapsed) {
        const burstEnergy = clamp((phase - P2) / (P3 - P2), 0, 1);
        const liftProgress = clamp((phase - FUNNEL_START) / Math.max(0.001, P4 - FUNNEL_START), 0, 1);
        const showProgress = clamp((phase - FUNNEL_START) / 0.11, 0, 1);
        if (showProgress <= 0) return;

        const uCount = 26;
        const vCount = 20;

        ctx.save();
        ctx.strokeStyle = "rgba(119, 128, 144, 0.4)";
        ctx.lineWidth = 0.9;
        ctx.globalAlpha = (0.09 + showProgress * 0.58) * lerp(0.85, 1, burstEnergy);

        if (liftProgress < 0.3) {
          const ringT = liftProgress / 0.3;
          const rr = lerp(width * 0.016, width * 0.08, easeOutCubic(ringT));
          ctx.globalAlpha = lerp(0.56, 0.2, ringT);
          ctx.strokeStyle = "rgba(115, 124, 142, 0.5)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.ellipse(cx, cy, rr, rr * 0.95, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        for (let ui = 0; ui < uCount; ui += 1) {
          const u = (ui / uCount) * Math.PI * 2;
          ctx.beginPath();
          for (let vi = 0; vi <= vCount; vi += 1) {
            const v = -1 + (vi / vCount) * 2;
            const p = funnelPoint(u, v, liftProgress, elapsed);
            if (vi === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        }

        for (let vi = 0; vi <= vCount; vi += 2) {
          const v = -1 + (vi / vCount) * 2;
          ctx.beginPath();
          for (let ui = 0; ui <= uCount; ui += 1) {
            const u = (ui / uCount) * Math.PI * 2;
            const p = funnelPoint(u, v, liftProgress, elapsed);
            if (ui === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        }

        ctx.globalAlpha = 0.22 + showProgress * 0.44;
        ctx.fillStyle = "rgba(19, 24, 35, 0.78)";
        for (let ui = 0; ui < uCount; ui += 1) {
          const u = (ui / uCount) * Math.PI * 2;
          const top = funnelPoint(u, -1, liftProgress, elapsed);
          const bottom = funnelPoint(u, 1, liftProgress, elapsed);
          ctx.beginPath();
          ctx.arc(top.x, top.y, 1.8, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(bottom.x, bottom.y, 1.8, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      function drawTextParticles(phase, elapsed) {
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        for (let i = 0; i < textParticles.length; i += 1) {
          const p = textParticles[i];
          let x = p.tx;
          let y = p.ty;
          let alpha = 1;
          let size = p.size;

          if (phase < P0) {
            x = p.tx;
            y = p.ty;
            alpha = 0;
          } else if (phase < P1) {
            const t = easeInOutCubic((phase - P0) / (P1 - P0));
            const drift = Math.pow(t, 1.45);
            x = lerp(p.tx, p.scatterX, drift);
            y = lerp(p.ty, p.scatterY, drift);
            alpha = lerp(0.05, 0.74, t);
          } else if (phase < P2) {
            const t = easeInOutCubic((phase - P1) / (P2 - P1));
            const convergeX = lerp(p.scatterX, p.centerX, t);
            const convergeY = lerp(p.scatterY, p.centerY, t);
            const collapse = easeInOutCubic(t);
            x = lerp(convergeX, cx, collapse * 0.92);
            y = lerp(convergeY, cy, collapse * 0.92);
            alpha = lerp(0.62, 0, t);
            size = lerp(p.size, 0, t);
          } else if (phase < P3) {
            const t = easeInOutSine((phase - P2) / (P3 - P2));
            x = lerp(p.centerX, p.burstX, t);
            y = lerp(p.centerY, p.burstY, t);
            alpha = lerp(0.04, 0.8, t);
            size = lerp(p.size * 0.45, p.size * 1.15, t);
          } else if (phase < P4) {
            const t = easeInOutSine((phase - P3) / (P4 - P3));
            x = p.burstX + Math.cos(p.seed + elapsed * 0.0018) * 16;
            y = p.burstY + Math.sin(p.seed + elapsed * 0.0021) * 16;
            alpha = lerp(0.8, 0.24, t);
            size = lerp(p.size * 1.1, p.size * 0.8, t);
          } else {
            const t = easeInOutCubic((phase - P4) / (1 - P4));
            x = p.burstX + Math.cos(p.seed + elapsed * 0.0016) * 12;
            y = p.burstY + Math.sin(p.seed + elapsed * 0.0019) * 12;
            alpha = lerp(0.24, 0.02, t);
            size = lerp(p.size * 0.8, p.size * 0.3, t);
          }

          x = clamp(x, edgeGutter, width - edgeGutter);

          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;

          if (p.square) {
            const s = Math.max(0.8, size * 1.25);
            ctx.fillRect(x - s / 2, y - s / 2, s, s);
          } else {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
      }

      function drawAmbient(phase, elapsed) {
        const visibility = clamp((phase - P2) / 0.15, 0, 1);
        if (visibility <= 0) return;
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const maxDX = cx - edgeGutter;
        const maxDY = cy - edgeGutter * 0.8;

        for (let i = 0; i < ambientParticles.length; i += 1) {
          const p = ambientParticles[i];
          const radius = p.radius + Math.sin(elapsed * 0.00095 + p.drift) * 18;
          const angle = p.angle + elapsed * p.spin;
          const z = p.depth + Math.sin(elapsed * p.zSpeed + p.zPhase) * 0.24;
          const perspective = lerp(0.62, 1.34, clamp(z, 0, 1));
          const rawDX = Math.cos(angle) * radius * perspective;
          const rawDY = Math.sin(angle) * radius * 0.32 * perspective + p.drift;
          const x = cx + clamp(rawDX, -maxDX, maxDX);
          const y = cy + clamp(rawDY, -maxDY, maxDY);
          const size = p.size * perspective;
          const alpha = p.alpha * lerp(0.55, 1, clamp(z, 0, 1));

          ctx.globalAlpha = alpha * visibility;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalAlpha = 1;
      }

      function drawSettledParticles(elapsed) {
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        for (let i = 0; i < textParticles.length; i += 1) {
          const p = textParticles[i];
          const wobble = 14 + (p.nx + 1) * 4;
          const x = clamp(p.burstX + Math.cos(p.seed + elapsed * 0.00125) * wobble, edgeGutter, width - edgeGutter);
          const y = p.burstY + Math.sin(p.seed + elapsed * 0.00155) * wobble * 0.85;
          const alpha = 0.16 + ((Math.sin(p.seed + elapsed * 0.0011) + 1) * 0.5) * 0.2;
          const size = p.size * (0.72 + ((Math.cos(p.seed + elapsed * 0.0013) + 1) * 0.5) * 0.4);

          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;

          if (p.square) {
            const s = Math.max(0.7, size * 1.2);
            ctx.fillRect(x - s / 2, y - s / 2, s, s);
          } else {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
      }

      function frame(now) {
        if (!running) return;

        const elapsed = now - startTime;
        const settledMode = elapsed >= CYCLE_MS;
        const phase = settledMode ? P4 : clamp(elapsed / CYCLE_MS, 0, 1);

        const showActions = phase >= 0.82;
        const cardProgress = clamp((phase - 0.79) / 0.14, 0, 1);
        fallbackTitle.classList.remove("is-visible");
        fallbackTitle.style.opacity = "0";

        actionGrid.classList.toggle("is-visible", showActions);
        actionItems.forEach((item, index) => {
          const threshold = index * 0.28;
          item.classList.toggle("is-on", showActions && cardProgress > threshold);
        });

        ctx.clearRect(0, 0, width, height);
        drawBackgroundGlow();
        drawSourceTitle(phase);
        drawFunnel(phase, elapsed);
        drawAmbient(phase, elapsed);
        if (settledMode) {
          drawSettledParticles(elapsed);
        } else if (phase >= P0) {
          drawTextParticles(phase, elapsed);
        }

        rafId = window.requestAnimationFrame(frame);
      }

      function stop() {
        running = false;
        if (rafId) window.cancelAnimationFrame(rafId);
      }

      const resizeObserver = new ResizeObserver(() => {
        initScene();
      });
      resizeObserver.observe(root);

      const visibilityHandler = () => {
        if (document.hidden) {
          pausedAt = performance.now();
          stop();
        } else {
          if (pausedAt) {
            startTime += performance.now() - pausedAt;
            pausedAt = 0;
          }
          running = true;
          rafId = window.requestAnimationFrame(frame);
        }
      };

      document.addEventListener("visibilitychange", visibilityHandler);
      mediaReduce.addEventListener("change", () => window.location.reload());

      initScene();
      rafId = window.requestAnimationFrame(frame);

      window.addEventListener(
        "beforeunload",
        () => {
          stop();
          resizeObserver.disconnect();
          document.removeEventListener("visibilitychange", visibilityHandler);
        },
        { once: true },
      );
    })();
  </script>
</section>
