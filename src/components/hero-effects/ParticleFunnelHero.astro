---
import type { SiteLocale } from "../../utils/i18n";

interface Props {
  locale?: SiteLocale;
}

const { locale = "zh-CN" } = Astro.props;
const isEn = locale === "en-US";
---

<section class="hero-stage" data-hero-root>
  <canvas class="hero-canvas" data-hero-canvas aria-hidden="true"></canvas>

  <div class="hero-centerline" aria-hidden="true"></div>

  <p class="hero-fallback-title" data-hero-fallback-title>
    <span>OVER THE </span><strong>RAINBOW</strong>
  </p>

  <article class="hero-copy-card" data-hero-copy>
    <h1>Let's Build , let's Realize</h1>
    <p>{isEn ? "From idea to reality, changing the world with code." : "从想法到现实，用代码改变世界。"}</p>
    <div class="hero-copy-actions">
      <a class="header-cta" href={isEn ? "/en/posts/" : "/posts/"}>{isEn ? "Get Started" : "开始阅读"}</a>
      <a class="home-intro-link" href={isEn ? "/en/about/" : "/about/"}>{isEn ? "View Architecture" : "查看架构"}</a>
    </div>
  </article>

  <div class="hero-action-grid" data-hero-actions>
    <article>
      <h2>HOME</h2>
      <p>{isEn ? "Landing page" : "站点首页"}</p>
      <a href={isEn ? "/en/" : "/"}>{isEn ? "Open" : "进入"}</a>
    </article>
    <article class="is-primary">
      <h2>POSTS</h2>
      <p>{isEn ? "All articles" : "全部文章"}</p>
      <a href={isEn ? "/en/posts/" : "/posts/"}>{isEn ? "Open" : "进入"}</a>
    </article>
    <article>
      <h2>TAGS</h2>
      <p>{isEn ? "Topic index" : "主题索引"}</p>
      <a href={isEn ? "/en/tags/" : "/tags/"}>{isEn ? "Open" : "进入"}</a>
    </article>
  </div>

  <script is:inline data-astro-rerun>
    (() => {
      const root = document.querySelector("[data-hero-root]");
      const canvas = root?.querySelector("[data-hero-canvas]");
      const actionGrid = root?.querySelector("[data-hero-actions]");
      const heroCopy = root?.querySelector("[data-hero-copy]");
      const fallbackTitle = root?.querySelector("[data-hero-fallback-title]");
      if (!root || !canvas || !actionGrid || !heroCopy || !fallbackTitle) return;

      const actionItems = Array.from(actionGrid.querySelectorAll("article"));

      const mediaReduce = window.matchMedia("(prefers-reduced-motion: reduce)");
      if (mediaReduce.matches) {
        root.classList.add("is-reduced");
        fallbackTitle.classList.add("is-visible");
        heroCopy.classList.add("is-visible");
        heroCopy.style.setProperty("--copy-progress", "1");
        actionGrid.classList.add("is-visible");
        actionItems.forEach((item) => item.classList.add("is-on"));
        return;
      }

      const ctx = canvas.getContext("2d", { alpha: true });
      if (!ctx) {
        root.classList.add("is-reduced");
        fallbackTitle.classList.add("is-visible");
        heroCopy.classList.add("is-visible");
        heroCopy.style.setProperty("--copy-progress", "1");
        actionGrid.classList.add("is-visible");
        actionItems.forEach((item) => item.classList.add("is-on"));
        return;
      }
      fallbackTitle.classList.remove("is-visible");
      fallbackTitle.style.opacity = "0";

      const CYCLE_MS = 12500;
      const TEXT = "OVER THE RAINBOW";
      const SAMPLE_STEP = 4;
      const MAX_TEXT_PARTICLES = 980;
      const AMBIENT_COUNT = 120;
      const EDGE_GUTTER_MIN = 24;

      const P0 = 0.14;
      const P1 = 0.34;
      const P2 = 0.51;
      const P3 = 0.66;
      const P4 = 0.9;
      const FUNNEL_START = P2;
      const GEOMETRY_MODE = "cylinder-inner-diamond";

      const COLORS = ["#2166d1", "#f28e2b", "#e15759", "#76b041", "#6f49c7", "#27a4c9", "#f0d23f"];
      const TEXT_COLORS = ["#1a2235", "#2c4575", "#5c7598", "#8f7d50", "#839f5e", "#4a8ea3", "#7054a8"];

      let dpr = 1;
      let width = 0;
      let height = 0;
      let cx = 0;
      let cy = 0;

      let running = true;
      let rafId = 0;
      let startTime = performance.now();
      let pausedAt = 0;

      const textParticles = [];
      const ambientParticles = [];

      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const randomRange = (min, max) => min + Math.random() * (max - min);
      const weightedPick = (choices) => {
        const total = choices.reduce((sum, c) => sum + c.w, 0);
        let roll = Math.random() * total;
        for (let i = 0; i < choices.length; i += 1) {
          roll -= choices[i].w;
          if (roll <= 0) return choices[i];
        }
        return choices[choices.length - 1];
      };
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);
      const easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
      const AMBIENT_SHAPES = [
        { w: 0.34, type: "sphere" },
        { w: 0.2, type: "cube" },
        { w: 0.14, type: "diamond" },
        { w: 0.12, type: "cone" },
        { w: 0.1, type: "poly6" },
        { w: 0.1, type: "cylinder" },
      ];

      function setCanvasSize() {
        const rect = root.getBoundingClientRect();
        dpr = clamp(window.devicePixelRatio || 1, 1, 2);
        width = Math.max(320, Math.floor(rect.width));
        height = Math.max(420, Math.floor(rect.height));
        cx = width / 2;
        cy = height / 2;

        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function textColorForX(x, minX, maxX) {
        const t = clamp((x - minX) / Math.max(1, maxX - minX), 0, 1);
        const idx = clamp(Math.floor(t * TEXT_COLORS.length), 0, TEXT_COLORS.length - 1);
        return TEXT_COLORS[idx];
      }

      function buildTextParticles() {
        textParticles.length = 0;

        const offscreen = document.createElement("canvas");
        offscreen.width = width;
        offscreen.height = height;
        const offctx = offscreen.getContext("2d");
        if (!offctx) return;

        const fontSize = Math.floor(clamp(width * 0.062, 34, 72));
        offctx.clearRect(0, 0, width, height);
        offctx.fillStyle = "#000";
        offctx.font = `500 ${fontSize}px "Manrope", sans-serif`;
        offctx.textAlign = "center";
        offctx.textBaseline = "middle";
        offctx.fillText(TEXT, cx, cy - 18);

        const imageData = offctx.getImageData(0, 0, width, height).data;
        const points = [];
        let minX = width;
        let maxX = 0;

        for (let y = 0; y < height; y += SAMPLE_STEP) {
          for (let x = 0; x < width; x += SAMPLE_STEP) {
            const a = imageData[(y * width + x) * 4 + 3];
            if (a > 80) {
              points.push({ x, y });
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
            }
          }
        }

        const stride = Math.max(1, Math.floor(points.length / MAX_TEXT_PARTICLES));
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const scatterRadiusXMax = Math.max(160, cx - edgeGutter - 10);
        const scatterRadiusYMax = Math.max(130, cy - edgeGutter - 10);
        const burstRadiusXMax = Math.max(120, cx - edgeGutter - 8);
        const burstRadiusYMax = Math.max(88, cy - edgeGutter - 12);

        for (let i = 0; i < points.length; i += stride) {
          const p = points[i];
          const angle = randomRange(0, Math.PI * 2);
          const scatterSpread = Math.sqrt(randomRange(0.08, 1));
          const scatterRadiusX = scatterRadiusXMax * scatterSpread;
          const scatterRadiusY = scatterRadiusYMax * scatterSpread * randomRange(0.92, 1.06);
          const nx = ((p.x - minX) / Math.max(1, maxX - minX)) * 2 - 1;
          const burstAngle = randomRange(0, Math.PI * 2);
          const burstSpread = randomRange(0.5, 0.98);
          const burstRadiusX = burstRadiusXMax * burstSpread;
          const burstRadiusY = burstRadiusYMax * burstSpread * randomRange(0.92, 1.05);

          const sizeBucket = weightedPick([
            { w: 0.82, min: 0.68, max: 1.45 },
            { w: 0.14, min: 1.55, max: 2.45 },
            { w: 0.04, min: 2.55, max: 3.9 },
          ]);

          textParticles.push({
            tx: p.x,
            ty: p.y,
            color: textColorForX(p.x, minX, maxX),
            size: randomRange(sizeBucket.min, sizeBucket.max),
            seed: randomRange(0, Math.PI * 2),
            nx,
            ny: (p.y - cy) / Math.max(1, height * 0.35),
            scatterX: cx + Math.cos(angle) * scatterRadiusX,
            scatterY: cy + Math.sin(angle) * scatterRadiusY,
            centerX: cx + randomRange(-6, 6),
            centerY: cy + randomRange(-6, 6),
            burstX: cx + Math.cos(burstAngle) * burstRadiusX,
            burstY: cy + Math.sin(burstAngle) * burstRadiusY,
            square: Math.random() > 0.25,
          });
        }
      }

      function buildAmbientParticles() {
        ambientParticles.length = 0;
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const maxRadiusX = Math.max(120, cx - edgeGutter - 10);
        const maxRadiusY = Math.max(90, cy - edgeGutter * 0.85);
        for (let i = 0; i < AMBIENT_COUNT; i += 1) {
          const sizeBucket = weightedPick([
            { w: 0.74, min: 1.1, max: 2.8 },
            { w: 0.2, min: 2.9, max: 5.5 },
            { w: 0.06, min: 5.6, max: 10.8 },
          ]);
          const depth = Math.pow(Math.random(), 1.45);
          const shapePick = weightedPick(AMBIENT_SHAPES);
          const radiusBase = randomRange(0.22, 0.98);
          const xStretch = randomRange(1.18, 1.42);
          const yStretch = randomRange(0.58, 0.84);

          ambientParticles.push({
            angle: randomRange(0, Math.PI * 2),
            radiusX: maxRadiusX * radiusBase * xStretch,
            radiusY: maxRadiusY * radiusBase * yStretch,
            spin: randomRange(0.0002, 0.00065) * (Math.random() > 0.5 ? 1 : -1),
            drift: randomRange(-26, 26),
            size: randomRange(sizeBucket.min, sizeBucket.max),
            alpha: randomRange(0.22, 0.86),
            depth,
            zPhase: randomRange(0, Math.PI * 2),
            zSpeed: randomRange(0.00045, 0.001),
            color: COLORS[i % COLORS.length],
            shape: shapePick.type,
            rotation: randomRange(0, Math.PI * 2),
            rotationSpeed: randomRange(-0.0013, 0.0013),
          });
        }
      }

      function drawAmbientShape(x, y, size, shape, angle) {
        switch (shape) {
          case "cube": {
            const s = Math.max(1, size * 1.52);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillRect(-s / 2, -s / 2, s, s);
            ctx.restore();
            return;
          }
          case "diamond": {
            const s = Math.max(1.1, size * 1.82);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.7);
            ctx.lineTo(s * 0.56, 0);
            ctx.lineTo(0, s * 0.7);
            ctx.lineTo(-s * 0.56, 0);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            return;
          }
          case "cone": {
            const h = Math.max(1.4, size * 2.2);
            const w = h * 0.92;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, -h * 0.64);
            ctx.lineTo(w * 0.52, h * 0.56);
            ctx.lineTo(-w * 0.52, h * 0.56);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            return;
          }
          case "poly6": {
            const r = Math.max(1.1, size * 1.5);
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            for (let i = 0; i < 6; i += 1) {
              const a = (i / 6) * Math.PI * 2;
              const px = Math.cos(a) * r;
              const py = Math.sin(a) * r;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            return;
          }
          case "cylinder": {
            const r = Math.max(1.2, size * 1.22);
            const h = r * 1.85;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.3, r, r * 0.45, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(-r, -h * 0.3, r * 2, h * 0.72);
            ctx.beginPath();
            ctx.ellipse(0, h * 0.42, r, r * 0.45, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            return;
          }
          case "sphere":
          default: {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function initScene() {
        setCanvasSize();
        buildTextParticles();
        buildAmbientParticles();
      }

      function drawBackgroundGlow() {
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, width * 0.46);
        gradient.addColorStop(0, "rgba(120, 150, 210, 0.075)");
        gradient.addColorStop(1, "rgba(120, 150, 210, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
      }

      function drawSourceTitle(phase) {
        if (phase >= P1) return;

        let alpha = 1;
        if (phase > P0) {
          const t = (phase - P0) / Math.max(0.001, P1 - P0);
          alpha = 1 - easeInOutCubic(t);
        }
        if (alpha <= 0) return;

        const fontSize = Math.floor(clamp(width * 0.062, 34, 72));
        const darkPart = "OVER THE ";
        const rainbowPart = "RAINBOW";

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = `500 ${fontSize}px "Manrope", sans-serif`;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        const darkWidth = ctx.measureText(darkPart).width;
        const rainbowWidth = ctx.measureText(rainbowPart).width;
        const startX = cx - (darkWidth + rainbowWidth) / 2;
        const y = cy - 18;

        ctx.fillStyle = "#16243f";
        ctx.fillText(darkPart, startX, y);

        const gradient = ctx.createLinearGradient(startX + darkWidth, y, startX + darkWidth + rainbowWidth, y);
        gradient.addColorStop(0, "#33496f");
        gradient.addColorStop(0.15, "#5f79ab");
        gradient.addColorStop(0.33, "#df9f52");
        gradient.addColorStop(0.5, "#c76064");
        gradient.addColorStop(0.66, "#76a84b");
        gradient.addColorStop(0.82, "#33a2c9");
        gradient.addColorStop(1, "#7054a8");
        ctx.fillStyle = gradient;
        ctx.fillText(rainbowPart, startX + darkWidth, y);
        ctx.restore();
      }

      function projectPoint(px, py, pz, liftProgress, elapsed) {
        const t = elapsed * 0.001;
        const growth = easeInOutCubic(liftProgress);
        const orbitAmp = easeOutCubic(liftProgress);
        const spin = elapsed * 0.00008;
        // Keep yaw continuously rotating, but avoid full tumble on pitch/roll.
        // Full continuous tumble on all axes causes wireframe self-overlap artifacts.
        const yaw = (t * 0.33 + Math.sin(t * 0.31) * 0.12) * orbitAmp;
        const cosSpin = Math.cos(spin);
        const sinSpin = Math.sin(spin);
        const sx = px * cosSpin - pz * sinSpin;
        const sy = py;
        const sz = px * sinSpin + pz * cosSpin;

        const pitchBase = lerp(-1.08, -0.56, growth);
        const pitch = pitchBase + Math.sin(t * 0.44) * 0.22 * orbitAmp;
        const cosX = Math.cos(pitch);
        const sinX = Math.sin(pitch);
        const ry = sy * cosX - sz * sinX;
        const rz1 = sy * sinX + sz * cosX;

        const cosY = Math.cos(yaw);
        const sinY = Math.sin(yaw);
        const rx = sx * cosY + rz1 * sinY;
        const rz = -sx * sinY + rz1 * cosY;

        const roll = Math.sin(t * 0.29) * 0.07 * orbitAmp;
        const cosZ = Math.cos(roll);
        const sinZ = Math.sin(roll);
        const fx = rx * cosZ - ry * sinZ;
        const fy = rx * sinZ + ry * cosZ;

        const zoom = lerp(0.76, 1.02, growth);
        const zTranslate = lerp(-430, -130, growth);
        const camera = 1360;
        const zWorld = rz * zoom + zTranslate;
        const perspective = camera / Math.max(200, camera - zWorld);

        return {
          x: cx + fx * zoom * perspective,
          y: cy + fy * zoom * perspective,
        };
      }

      function cylinderPoint(u, v, liftProgress, elapsed) {
        const base = Math.min(width, height);
        const aspect = width / Math.max(1, height);
        const wideT = clamp((aspect - 1) / 1.2, 0, 1);
        const diameterScale = 1.6;
        const growth = easeInOutCubic(liftProgress);

        const radiusTarget = base * lerp(0.42, 0.34, wideT) * diameterScale;
        const radius = radiusTarget * growth;
        const yExtentTarget = Math.min(height * 0.62, base * lerp(0.84, 0.96, wideT));
        const yExtent = yExtentTarget * growth;

        const angle = u;
        return projectPoint(Math.cos(angle) * radius, v * yExtent, Math.sin(angle) * radius, liftProgress, elapsed);
      }

      function diamondPoint(u, v, liftProgress, elapsed) {
        const base = Math.min(width, height);
        const aspect = width / Math.max(1, height);
        const wideT = clamp((aspect - 1) / 1.2, 0, 1);
        const growth = easeInOutCubic(liftProgress);

        const yExtentTarget = Math.min(height * 0.44, base * lerp(0.62, 0.72, wideT));
        const yExtent = yExtentTarget * growth;
        const peakRadiusTarget = base * lerp(0.28, 0.24, wideT);
        const peakRadius = peakRadiusTarget * growth;
        const absV = Math.abs(v);
        const radial = peakRadius * (1 - absV); // octahedron-like linear profile
        const angle = u;

        return projectPoint(Math.cos(angle) * radial, v * yExtent, Math.sin(angle) * radial, liftProgress, elapsed);
      }

      function drawFunnel(phase, elapsed) {
        const burstEnergy = clamp((phase - P2) / (P3 - P2), 0, 1);
        const liftProgress = clamp((phase - FUNNEL_START) / Math.max(0.001, P4 - FUNNEL_START), 0, 1);
        const showProgress = clamp((phase - FUNNEL_START) / 0.11, 0, 1);
        if (showProgress <= 0) return;

        const uCount = 26;
        const vCount = 20;

        ctx.save();
        ctx.strokeStyle = "rgba(119, 128, 144, 0.4)";
        ctx.lineWidth = 0.9;
        ctx.globalAlpha = (showProgress * 0.66) * lerp(0.85, 1, burstEnergy);

        if (liftProgress < 0.3) {
          const ringT = liftProgress / 0.3;
          const rr = lerp(0, width * 0.08, easeOutCubic(ringT));
          ctx.globalAlpha = lerp(0, 0.24, ringT) * showProgress;
          ctx.strokeStyle = "rgba(115, 124, 142, 0.5)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.ellipse(cx, cy, rr, rr * 0.95, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (GEOMETRY_MODE === "cylinder-inner-diamond") {
          // Outer cylinder shell
          for (let ui = 0; ui < uCount; ui += 1) {
            const u = (ui / uCount) * Math.PI * 2;
            ctx.beginPath();
            for (let vi = 0; vi <= vCount; vi += 1) {
              const v = -1 + (vi / vCount) * 2;
              const p = cylinderPoint(u, v, liftProgress, elapsed);
              if (vi === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
          }

          for (let vi = 0; vi <= vCount; vi += 2) {
            const v = -1 + (vi / vCount) * 2;
            ctx.beginPath();
            for (let ui = 0; ui <= uCount; ui += 1) {
              const u = (ui / uCount) * Math.PI * 2;
              const p = cylinderPoint(u, v, liftProgress, elapsed);
              if (ui === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
          }

          // Inner diamond mesh
          ctx.globalAlpha *= 0.92;
          for (let ui = 0; ui < uCount; ui += 1) {
            const u = (ui / uCount) * Math.PI * 2;
            ctx.beginPath();
            for (let vi = 0; vi <= vCount; vi += 1) {
              const v = -1 + (vi / vCount) * 2;
              const p = diamondPoint(u, v, liftProgress, elapsed);
              if (vi === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
          }

          for (let vi = 2; vi < vCount; vi += 3) {
            const v = -1 + (vi / vCount) * 2;
            ctx.beginPath();
            for (let ui = 0; ui <= uCount; ui += 1) {
              const u = (ui / uCount) * Math.PI * 2;
              const p = diamondPoint(u, v, liftProgress, elapsed);
              if (ui === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
          }

          // Central spine: connect top and bottom diamond apex through the core.
          const apexTop = diamondPoint(0, -1, liftProgress, elapsed);
          const apexBottom = diamondPoint(0, 1, liftProgress, elapsed);
          const dx = apexBottom.x - apexTop.x;
          const dy = apexBottom.y - apexTop.y;
          const len = Math.max(1, Math.hypot(dx, dy));
          const ux = dx / len;
          const uy = dy / len;
          const extend = Math.max(width, height) * 1.25;
          const exTopX = apexTop.x - ux * extend;
          const exTopY = apexTop.y - uy * extend;
          const exBottomX = apexBottom.x + ux * extend;
          const exBottomY = apexBottom.y + uy * extend;

          ctx.globalAlpha = Math.min(1, ctx.globalAlpha * 0.9);
          ctx.strokeStyle = "rgba(66, 76, 98, 0.42)";
          ctx.lineWidth = 1.35;
          ctx.lineCap = "round";
          ctx.shadowBlur = 4;
          ctx.shadowColor = "rgba(86, 98, 122, 0.12)";
          ctx.beginPath();
          ctx.moveTo(exTopX, exTopY);
          ctx.lineTo(exBottomX, exBottomY);
          ctx.stroke();
          ctx.shadowBlur = 0;
        } else {
          for (let ui = 0; ui < uCount; ui += 1) {
            const u = (ui / uCount) * Math.PI * 2;
            ctx.beginPath();
            for (let vi = 0; vi <= vCount; vi += 1) {
              const v = -1 + (vi / vCount) * 2;
              const p = cylinderPoint(u, v, liftProgress, elapsed);
              if (vi === 0) ctx.moveTo(p.x, p.y);
              else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
          }
        }

        if (liftProgress > 0.09) {
          const nodeReveal = clamp((liftProgress - 0.09) / 0.18, 0, 1);
          const nodeSize = lerp(1.2, 1.8, nodeReveal);
          ctx.globalAlpha = showProgress * 0.38 * nodeReveal;
          ctx.fillStyle = "rgba(76, 86, 106, 0.72)";
          for (let ui = 0; ui < uCount; ui += 1) {
            const u = (ui / uCount) * Math.PI * 2;
            const top = cylinderPoint(u, -1, liftProgress, elapsed);
            const bottom = cylinderPoint(u, 1, liftProgress, elapsed);
            ctx.beginPath();
            ctx.arc(top.x, top.y, nodeSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(bottom.x, bottom.y, nodeSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.restore();
      }

      function drawTextParticles(phase, elapsed) {
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        for (let i = 0; i < textParticles.length; i += 1) {
          const p = textParticles[i];
          let x = p.tx;
          let y = p.ty;
          let alpha = 1;
          let size = p.size;

          if (phase < P0) {
            x = p.tx;
            y = p.ty;
            alpha = 0;
          } else if (phase < P1) {
            const t = easeInOutCubic((phase - P0) / (P1 - P0));
            const drift = Math.pow(t, 1.45);
            x = lerp(p.tx, p.scatterX, drift);
            y = lerp(p.ty, p.scatterY, drift);
            alpha = lerp(0.05, 0.74, t);
          } else if (phase < P2) {
            const t = easeInOutCubic((phase - P1) / (P2 - P1));
            const convergeX = lerp(p.scatterX, p.centerX, t);
            const convergeY = lerp(p.scatterY, p.centerY, t);
            const collapse = easeInOutCubic(t);
            x = lerp(convergeX, cx, collapse * 0.92);
            y = lerp(convergeY, cy, collapse * 0.92);
            alpha = lerp(0.62, 0, t);
            size = lerp(p.size, 0, t);
          } else if (phase < P3) {
            const t = easeInOutSine((phase - P2) / (P3 - P2));
            const driftAmp = lerp(0, 16, t);
            x = lerp(p.centerX, p.burstX, t) + Math.cos(p.seed + elapsed * 0.0018) * driftAmp;
            y = lerp(p.centerY, p.burstY, t) + Math.sin(p.seed + elapsed * 0.0021) * driftAmp;
            alpha = lerp(0.04, 0.8, t);
            size = lerp(p.size * 0.45, p.size * 1.15, t);
          } else if (phase < P4) {
            const t = easeInOutSine((phase - P3) / (P4 - P3));
            const driftAmp = lerp(16, 15, t);
            x = p.burstX + Math.cos(p.seed + elapsed * 0.0018) * driftAmp;
            y = p.burstY + Math.sin(p.seed + elapsed * 0.0021) * driftAmp;
            alpha = lerp(0.8, 0.24, t);
            size = lerp(p.size * 1.1, p.size * 0.8, t);
          } else {
            const t = easeInOutCubic((phase - P4) / (1 - P4));
            x = p.burstX + Math.cos(p.seed + elapsed * 0.0016) * 12;
            y = p.burstY + Math.sin(p.seed + elapsed * 0.0019) * 12;
            alpha = lerp(0.24, 0.02, t);
            size = lerp(p.size * 0.8, p.size * 0.3, t);
          }

          x = clamp(x, edgeGutter, width - edgeGutter);

          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;

          if (p.square) {
            const s = Math.max(0.8, size * 1.25);
            ctx.fillRect(x - s / 2, y - s / 2, s, s);
          } else {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
      }

      function drawAmbient(phase, elapsed) {
        const visibility = clamp((phase - P2) / 0.15, 0, 1);
        if (visibility <= 0) return;
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        const maxDX = cx - edgeGutter * 0.8;
        const maxDY = cy - edgeGutter * 0.95;

        for (let i = 0; i < ambientParticles.length; i += 1) {
          const p = ambientParticles[i];
          const radiusX = p.radiusX + Math.sin(elapsed * 0.00095 + p.drift) * 26;
          const radiusY = p.radiusY + Math.cos(elapsed * 0.00103 + p.drift * 0.85) * 10;
          const angle = p.angle + elapsed * p.spin;
          const z = p.depth + Math.sin(elapsed * p.zSpeed + p.zPhase) * 0.24;
          const perspective = lerp(0.62, 1.34, clamp(z, 0, 1));
          const rawDX = Math.cos(angle) * radiusX * perspective;
          const rawDY = Math.sin(angle) * radiusY * 0.96 * perspective + p.drift;

          // Soft-limit to avoid hard edge stacking (which creates straight bands).
          const overX = Math.abs(rawDX) / Math.max(1, maxDX);
          const overY = Math.abs(rawDY) / Math.max(1, maxDY);
          const compress = 1 / Math.max(1, overX, overY);
          const x = cx + rawDX * compress;
          const y = cy + rawDY * compress;
          const size = p.size * perspective;
          const alpha = p.alpha * lerp(0.55, 1, clamp(z, 0, 1));
          const rotation = p.rotation + elapsed * p.rotationSpeed;

          ctx.globalAlpha = alpha * visibility;
          ctx.fillStyle = p.color;
          drawAmbientShape(x, y, size, p.shape, rotation);
        }

        ctx.globalAlpha = 1;
      }

      function drawSettledParticles(elapsed) {
        const edgeGutter = Math.max(EDGE_GUTTER_MIN, width * 0.03);
        for (let i = 0; i < textParticles.length; i += 1) {
          const p = textParticles[i];
          const wobble = 14 + (p.nx + 1) * 4;
          const x = clamp(p.burstX + Math.cos(p.seed + elapsed * 0.00125) * wobble, edgeGutter, width - edgeGutter);
          const y = p.burstY + Math.sin(p.seed + elapsed * 0.00155) * wobble * 0.85;
          const alpha = 0.16 + ((Math.sin(p.seed + elapsed * 0.0011) + 1) * 0.5) * 0.2;
          const size = p.size * (0.72 + ((Math.cos(p.seed + elapsed * 0.0013) + 1) * 0.5) * 0.4);

          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;

          if (p.square) {
            const s = Math.max(0.7, size * 1.2);
            ctx.fillRect(x - s / 2, y - s / 2, s, s);
          } else {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
      }

      function frame(now) {
        if (!running) return;

        const elapsed = now - startTime;
        const settledMode = elapsed >= CYCLE_MS;
        const phase = settledMode ? P4 : clamp(elapsed / CYCLE_MS, 0, 1);

        const showActions = phase >= 0.79;
        const copyStart = 0.22;
        const copyEnd = 0.46;
        const copyProgress = easeInOutCubic(clamp((phase - copyStart) / (copyEnd - copyStart), 0, 1));
        const showHeroCopy = copyProgress > 0.01;
        const cardProgress = clamp((phase - 0.79) / 0.14, 0, 1);
        fallbackTitle.classList.remove("is-visible");
        fallbackTitle.style.opacity = "0";

        heroCopy.style.setProperty("--copy-progress", String(copyProgress));
        heroCopy.classList.toggle("is-visible", showHeroCopy);
        actionGrid.classList.toggle("is-visible", showActions);
        const thresholds = [0, 0.33, 0.66];
        actionItems.forEach((item, index) => {
          item.classList.toggle("is-on", showActions && cardProgress >= (thresholds[index] ?? 1));
        });

        ctx.clearRect(0, 0, width, height);
        drawBackgroundGlow();
        drawSourceTitle(phase);
        drawFunnel(phase, elapsed);
        drawAmbient(phase, elapsed);
        if (settledMode) {
          drawSettledParticles(elapsed);
        } else if (phase >= P0) {
          drawTextParticles(phase, elapsed);
        }

        rafId = window.requestAnimationFrame(frame);
      }

      function stop() {
        running = false;
        if (rafId) window.cancelAnimationFrame(rafId);
      }

      const resizeObserver = new ResizeObserver(() => {
        initScene();
      });
      resizeObserver.observe(root);

      const visibilityHandler = () => {
        if (document.hidden) {
          pausedAt = performance.now();
          stop();
        } else {
          if (pausedAt) {
            startTime += performance.now() - pausedAt;
            pausedAt = 0;
          }
          running = true;
          rafId = window.requestAnimationFrame(frame);
        }
      };

      document.addEventListener("visibilitychange", visibilityHandler);
      mediaReduce.addEventListener("change", () => window.location.reload());

      initScene();
      rafId = window.requestAnimationFrame(frame);

      const cleanup = () => {
        stop();
        resizeObserver.disconnect();
        document.removeEventListener("visibilitychange", visibilityHandler);
      };

      document.addEventListener("astro:before-swap", cleanup, { once: true });
      window.addEventListener("beforeunload", cleanup, { once: true });
    })();
  </script>
</section>


